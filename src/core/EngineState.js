import {EventEmitter} from '../utils/EventEmitter.js'
export const EnginePhase=Object.freeze({
CREATED:0,
INITIALIZING:1,
INITIALIZED:2,
STARTING:3,
RUNNING:4,
PAUSED:5,
STOPPING:6,
STOPPED:7,
DESTROYED:8,
ERROR:9
})
export class EngineState extends EventEmitter{
constructor(){
super()
this.phase=EnginePhase.CREATED
this.previousPhase=null
this.frame=0
this.time=0
this.delta=0
this.fixedDelta=1/60
this.accumulator=0
this.timeScale=1
this.maxDelta=0.25
this.startTime=0
this.lastTime=0
this.pauseTime=0
this.resumeTime=0
this.running=false
this.paused=false
this.stopped=false
this.destroyed=false
this.error=null
this.flags={
initialized:false,
started:false,
ready:false,
visible:true,
focused:true
}
this.metrics={
fps:0,
frameTime:0,
cpuTime:0,
gpuTime:0,
memory:0
}
this._fpsAccumulator=0
this._fpsFrames=0
this._fpsTime=0
}
setPhase(newPhase){
if(this.phase===newPhase)return
this.previousPhase=this.phase
this.phase=newPhase
this.emit('phase',newPhase,this.previousPhase)
this.emit(`phase:${newPhase}`,newPhase,this.previousPhase)
}
markInitialized(){
this.flags.initialized=true
this.setPhase(EnginePhase.INITIALIZED)
}
markStarting(){
this.setPhase(EnginePhase.STARTING)
}
markRunning(){
this.running=true
this.paused=false
this.stopped=false
this.startTime=performance.now()
this.lastTime=this.startTime
this.setPhase(EnginePhase.RUNNING)
}
markPaused(){
if(this.paused)return
this.paused=true
this.running=false
this.pauseTime=performance.now()
this.setPhase(EnginePhase.PAUSED)
}
markResumed(){
if(!this.paused)return
this.paused=false
this.running=true
this.resumeTime=performance.now()
this.lastTime=this.resumeTime
this.setPhase(EnginePhase.RUNNING)
}
markStopping(){
this.running=false
this.setPhase(EnginePhase.STOPPING)
}
markStopped(){
this.running=false
this.stopped=true
this.setPhase(EnginePhase.STOPPED)
}
markDestroyed(){
this.destroyed=true
this.running=false
this.setPhase(EnginePhase.DESTROYED)
}
markError(error){
this.error=error
this.running=false
this.setPhase(EnginePhase.ERROR)
this.emit('error',error)
}
step(now){
if(this.destroyed||this.stopped)return false
if(!this.running)return false
const rawDelta=(now-this.lastTime)/1000
this.lastTime=now
const clampedDelta=Math.min(rawDelta,this.maxDelta)
const scaledDelta=clampedDelta*this.timeScale
this.delta=scaledDelta
this.time+=scaledDelta
this.frame++
this.accumulator+=scaledDelta
this.metrics.frameTime=scaledDelta
this.updateFPS(now,scaledDelta)
this.emit('step',scaledDelta,this.time,this.frame)
return true
}
updateFPS(now,delta){
this._fpsAccumulator+=delta
this._fpsFrames++
if(this._fpsAccumulator>=0.5){
this.metrics.fps=this._fpsFrames/this._fpsAccumulator
this._fpsAccumulator=0
this._fpsFrames=0
}
}
consumeFixedStep(){
if(this.accumulator>=this.fixedDelta){
this.accumulator-=this.fixedDelta
return this.fixedDelta
}
return 0
}
setTimeScale(scale){
this.timeScale=Math.max(0,scale)
this.emit('timescale',this.timeScale)
}
setFixedDelta(dt){
this.fixedDelta=dt
}
setMaxDelta(dt){
this.maxDelta=dt
}
setVisible(visible){
this.flags.visible=visible
this.emit('visible',visible)
}
setFocused(focused){
this.flags.focused=focused
this.emit('focused',focused)
}
setReady(ready=true){
this.flags.ready=ready
this.emit('ready',ready)
}
setMemoryUsage(bytes){
this.metrics.memory=bytes
}
setCPUTime(ms){
this.metrics.cpuTime=ms
}
setGPUTime(ms){
this.metrics.gpuTime=ms
}
reset(){
this.frame=0
this.time=0
this.delta=0
this.accumulator=0
this.metrics.fps=0
this.metrics.frameTime=0
this._fpsAccumulator=0
this._fpsFrames=0
}
isRunning(){
return this.phase===EnginePhase.RUNNING
}
isPaused(){
return this.phase===EnginePhase.PAUSED
}
isStopped(){
return this.phase===EnginePhase.STOPPED
}
isDestroyed(){
return this.phase===EnginePhase.DESTROYED
}
destroy(){
this.markDestroyed()
this.removeAllListeners()
}
}
